/* tslint:disable */
/* eslint-disable */
/**
 * IdentityServer Admin api
 * Api for administration.
 *
 * The version of the OpenAPI document: 2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    AdminClientDto,
    AdminClientDtoFromJSON,
    AdminClientDtoToJSON,
    AdminCreateClientDto,
    AdminCreateClientDtoFromJSON,
    AdminCreateClientDtoToJSON,
    AdminCreateScopeDto,
    AdminCreateScopeDtoFromJSON,
    AdminCreateScopeDtoToJSON,
    AdminPatchClientDto,
    AdminPatchClientDtoFromJSON,
    AdminPatchClientDtoToJSON,
    AdminPatchScopeDto,
    AdminPatchScopeDtoFromJSON,
    AdminPatchScopeDtoToJSON,
    AdminScopeDTO,
    AdminScopeDTOFromJSON,
    AdminScopeDTOToJSON,
    ClientSecretDto,
    ClientSecretDtoFromJSON,
    ClientSecretDtoToJSON,
    HttpProblemResponse,
    HttpProblemResponseFromJSON,
    HttpProblemResponseToJSON,
    PaginatedDelegationProviderDto,
    PaginatedDelegationProviderDtoFromJSON,
    PaginatedDelegationProviderDtoToJSON,
    TenantDto,
    TenantDtoFromJSON,
    TenantDtoToJSON,
} from '../models';

export interface MeClientSecretsControllerCreateRequest {
    tenantId: string;
    clientId: string;
}

export interface MeClientSecretsControllerDeleteRequest {
    tenantId: string;
    clientId: string;
    secretId: string;
}

export interface MeClientSecretsControllerFindAllRequest {
    tenantId: string;
    clientId: string;
}

export interface MeClientsControllerCreateRequest {
    tenantId: string;
    adminCreateClientDto: AdminCreateClientDto;
}

export interface MeClientsControllerDeleteRequest {
    clientId: string;
    tenantId: string;
}

export interface MeClientsControllerFindByTenantIdRequest {
    tenantId: string;
}

export interface MeClientsControllerFindByTenantIdAndClientIdRequest {
    tenantId: string;
    clientId: string;
    includeArchived: boolean;
}

export interface MeClientsControllerUpdateRequest {
    tenantId: string;
    clientId: string;
    adminPatchClientDto: AdminPatchClientDto;
}

export interface MeClientsScopesControllerFindAllRequest {
    tenantId: string;
    clientId: string;
}

export interface MeScopesControllerCreateRequest {
    tenantId: string;
    adminCreateScopeDto: AdminCreateScopeDto;
}

export interface MeScopesControllerFindAllByTenantIdRequest {
    tenantId: string;
}

export interface MeScopesControllerFindByTenantIdAndScopeNameRequest {
    tenantId: string;
    scopeName: string;
}

export interface MeScopesControllerUpdateRequest {
    tenantId: string;
    scopeName: string;
    adminPatchScopeDto: AdminPatchScopeDto;
}

export interface MeTenantsControllerFindByIdRequest {
    tenantId: string;
}

/**
 * 
 */
export class AdminApi extends runtime.BaseAPI {

    /**
     * Create a new client secret for the specified tenant and client.
     */
    async meClientSecretsControllerCreateRaw(requestParameters: MeClientSecretsControllerCreateRequest): Promise<runtime.ApiResponse<ClientSecretDto>> {
        if (requestParameters.tenantId === null || requestParameters.tenantId === undefined) {
            throw new runtime.RequiredError('tenantId','Required parameter requestParameters.tenantId was null or undefined when calling meClientSecretsControllerCreate.');
        }

        if (requestParameters.clientId === null || requestParameters.clientId === undefined) {
            throw new runtime.RequiredError('clientId','Required parameter requestParameters.clientId was null or undefined when calling meClientSecretsControllerCreate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("ias", ["@admin.island.is/auth", "@admin.island.is/auth:admin"]);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/v2/me/tenants/{tenantId}/clients/{clientId}/secrets`.replace(`{${"tenantId"}}`, encodeURIComponent(String(requestParameters.tenantId))).replace(`{${"clientId"}}`, encodeURIComponent(String(requestParameters.clientId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ClientSecretDtoFromJSON(jsonValue));
    }

    /**
     * Create a new client secret for the specified tenant and client.
     */
    async meClientSecretsControllerCreate(requestParameters: MeClientSecretsControllerCreateRequest): Promise<ClientSecretDto> {
        const response = await this.meClientSecretsControllerCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Delete a client secret for the specified tenant and client.
     */
    async meClientSecretsControllerDeleteRaw(requestParameters: MeClientSecretsControllerDeleteRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.tenantId === null || requestParameters.tenantId === undefined) {
            throw new runtime.RequiredError('tenantId','Required parameter requestParameters.tenantId was null or undefined when calling meClientSecretsControllerDelete.');
        }

        if (requestParameters.clientId === null || requestParameters.clientId === undefined) {
            throw new runtime.RequiredError('clientId','Required parameter requestParameters.clientId was null or undefined when calling meClientSecretsControllerDelete.');
        }

        if (requestParameters.secretId === null || requestParameters.secretId === undefined) {
            throw new runtime.RequiredError('secretId','Required parameter requestParameters.secretId was null or undefined when calling meClientSecretsControllerDelete.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("ias", ["@admin.island.is/auth", "@admin.island.is/auth:admin"]);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/v2/me/tenants/{tenantId}/clients/{clientId}/secrets/{secretId}`.replace(`{${"tenantId"}}`, encodeURIComponent(String(requestParameters.tenantId))).replace(`{${"clientId"}}`, encodeURIComponent(String(requestParameters.clientId))).replace(`{${"secretId"}}`, encodeURIComponent(String(requestParameters.secretId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a client secret for the specified tenant and client.
     */
    async meClientSecretsControllerDelete(requestParameters: MeClientSecretsControllerDeleteRequest): Promise<void> {
        await this.meClientSecretsControllerDeleteRaw(requestParameters);
    }

    /**
     * Get all client secrets for the specified client and tenant.
     */
    async meClientSecretsControllerFindAllRaw(requestParameters: MeClientSecretsControllerFindAllRequest): Promise<runtime.ApiResponse<Array<ClientSecretDto>>> {
        if (requestParameters.tenantId === null || requestParameters.tenantId === undefined) {
            throw new runtime.RequiredError('tenantId','Required parameter requestParameters.tenantId was null or undefined when calling meClientSecretsControllerFindAll.');
        }

        if (requestParameters.clientId === null || requestParameters.clientId === undefined) {
            throw new runtime.RequiredError('clientId','Required parameter requestParameters.clientId was null or undefined when calling meClientSecretsControllerFindAll.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("ias", ["@admin.island.is/auth", "@admin.island.is/auth:admin"]);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/v2/me/tenants/{tenantId}/clients/{clientId}/secrets`.replace(`{${"tenantId"}}`, encodeURIComponent(String(requestParameters.tenantId))).replace(`{${"clientId"}}`, encodeURIComponent(String(requestParameters.clientId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ClientSecretDtoFromJSON));
    }

    /**
     * Get all client secrets for the specified client and tenant.
     */
    async meClientSecretsControllerFindAll(requestParameters: MeClientSecretsControllerFindAllRequest): Promise<Array<ClientSecretDto>> {
        const response = await this.meClientSecretsControllerFindAllRaw(requestParameters);
        return await response.value();
    }

    /**
     * Create a new client for the specified tenant.
     */
    async meClientsControllerCreateRaw(requestParameters: MeClientsControllerCreateRequest): Promise<runtime.ApiResponse<AdminClientDto>> {
        if (requestParameters.tenantId === null || requestParameters.tenantId === undefined) {
            throw new runtime.RequiredError('tenantId','Required parameter requestParameters.tenantId was null or undefined when calling meClientsControllerCreate.');
        }

        if (requestParameters.adminCreateClientDto === null || requestParameters.adminCreateClientDto === undefined) {
            throw new runtime.RequiredError('adminCreateClientDto','Required parameter requestParameters.adminCreateClientDto was null or undefined when calling meClientsControllerCreate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("ias", ["@admin.island.is/auth", "@admin.island.is/auth:admin"]);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/v2/me/tenants/{tenantId}/clients`.replace(`{${"tenantId"}}`, encodeURIComponent(String(requestParameters.tenantId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AdminCreateClientDtoToJSON(requestParameters.adminCreateClientDto),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AdminClientDtoFromJSON(jsonValue));
    }

    /**
     * Create a new client for the specified tenant.
     */
    async meClientsControllerCreate(requestParameters: MeClientsControllerCreateRequest): Promise<AdminClientDto> {
        const response = await this.meClientsControllerCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Delete a client.
     */
    async meClientsControllerDeleteRaw(requestParameters: MeClientsControllerDeleteRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.clientId === null || requestParameters.clientId === undefined) {
            throw new runtime.RequiredError('clientId','Required parameter requestParameters.clientId was null or undefined when calling meClientsControllerDelete.');
        }

        if (requestParameters.tenantId === null || requestParameters.tenantId === undefined) {
            throw new runtime.RequiredError('tenantId','Required parameter requestParameters.tenantId was null or undefined when calling meClientsControllerDelete.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("ias", ["@admin.island.is/auth", "@admin.island.is/auth:admin"]);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/v2/me/tenants/{tenantId}/clients/{clientId}`.replace(`{${"clientId"}}`, encodeURIComponent(String(requestParameters.clientId))).replace(`{${"tenantId"}}`, encodeURIComponent(String(requestParameters.tenantId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a client.
     */
    async meClientsControllerDelete(requestParameters: MeClientsControllerDeleteRequest): Promise<void> {
        await this.meClientsControllerDeleteRaw(requestParameters);
    }

    /**
     * Get all clients for the specified tenant.
     */
    async meClientsControllerFindByTenantIdRaw(requestParameters: MeClientsControllerFindByTenantIdRequest): Promise<runtime.ApiResponse<Array<AdminClientDto>>> {
        if (requestParameters.tenantId === null || requestParameters.tenantId === undefined) {
            throw new runtime.RequiredError('tenantId','Required parameter requestParameters.tenantId was null or undefined when calling meClientsControllerFindByTenantId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("ias", ["@admin.island.is/auth", "@admin.island.is/auth:admin"]);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/v2/me/tenants/{tenantId}/clients`.replace(`{${"tenantId"}}`, encodeURIComponent(String(requestParameters.tenantId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AdminClientDtoFromJSON));
    }

    /**
     * Get all clients for the specified tenant.
     */
    async meClientsControllerFindByTenantId(requestParameters: MeClientsControllerFindByTenantIdRequest): Promise<Array<AdminClientDto>> {
        const response = await this.meClientsControllerFindByTenantIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get client by id and tenant for the current user.
     */
    async meClientsControllerFindByTenantIdAndClientIdRaw(requestParameters: MeClientsControllerFindByTenantIdAndClientIdRequest): Promise<runtime.ApiResponse<AdminClientDto>> {
        if (requestParameters.tenantId === null || requestParameters.tenantId === undefined) {
            throw new runtime.RequiredError('tenantId','Required parameter requestParameters.tenantId was null or undefined when calling meClientsControllerFindByTenantIdAndClientId.');
        }

        if (requestParameters.clientId === null || requestParameters.clientId === undefined) {
            throw new runtime.RequiredError('clientId','Required parameter requestParameters.clientId was null or undefined when calling meClientsControllerFindByTenantIdAndClientId.');
        }

        if (requestParameters.includeArchived === null || requestParameters.includeArchived === undefined) {
            throw new runtime.RequiredError('includeArchived','Required parameter requestParameters.includeArchived was null or undefined when calling meClientsControllerFindByTenantIdAndClientId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.includeArchived !== undefined) {
            queryParameters['includeArchived'] = requestParameters.includeArchived;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("ias", ["@admin.island.is/auth", "@admin.island.is/auth:admin"]);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/v2/me/tenants/{tenantId}/clients/{clientId}`.replace(`{${"tenantId"}}`, encodeURIComponent(String(requestParameters.tenantId))).replace(`{${"clientId"}}`, encodeURIComponent(String(requestParameters.clientId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AdminClientDtoFromJSON(jsonValue));
    }

    /**
     * Get client by id and tenant for the current user.
     */
    async meClientsControllerFindByTenantIdAndClientId(requestParameters: MeClientsControllerFindByTenantIdAndClientIdRequest): Promise<AdminClientDto> {
        const response = await this.meClientsControllerFindByTenantIdAndClientIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update a client with partial set of properties.
     */
    async meClientsControllerUpdateRaw(requestParameters: MeClientsControllerUpdateRequest): Promise<runtime.ApiResponse<AdminClientDto>> {
        if (requestParameters.tenantId === null || requestParameters.tenantId === undefined) {
            throw new runtime.RequiredError('tenantId','Required parameter requestParameters.tenantId was null or undefined when calling meClientsControllerUpdate.');
        }

        if (requestParameters.clientId === null || requestParameters.clientId === undefined) {
            throw new runtime.RequiredError('clientId','Required parameter requestParameters.clientId was null or undefined when calling meClientsControllerUpdate.');
        }

        if (requestParameters.adminPatchClientDto === null || requestParameters.adminPatchClientDto === undefined) {
            throw new runtime.RequiredError('adminPatchClientDto','Required parameter requestParameters.adminPatchClientDto was null or undefined when calling meClientsControllerUpdate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("ias", ["@admin.island.is/auth", "@admin.island.is/auth:admin"]);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/v2/me/tenants/{tenantId}/clients/{clientId}`.replace(`{${"tenantId"}}`, encodeURIComponent(String(requestParameters.tenantId))).replace(`{${"clientId"}}`, encodeURIComponent(String(requestParameters.clientId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: AdminPatchClientDtoToJSON(requestParameters.adminPatchClientDto),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AdminClientDtoFromJSON(jsonValue));
    }

    /**
     * Update a client with partial set of properties.
     */
    async meClientsControllerUpdate(requestParameters: MeClientsControllerUpdateRequest): Promise<AdminClientDto> {
        const response = await this.meClientsControllerUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Gets all allowed scopes for the specified client and tenant.
     */
    async meClientsScopesControllerFindAllRaw(requestParameters: MeClientsScopesControllerFindAllRequest): Promise<runtime.ApiResponse<Array<AdminScopeDTO>>> {
        if (requestParameters.tenantId === null || requestParameters.tenantId === undefined) {
            throw new runtime.RequiredError('tenantId','Required parameter requestParameters.tenantId was null or undefined when calling meClientsScopesControllerFindAll.');
        }

        if (requestParameters.clientId === null || requestParameters.clientId === undefined) {
            throw new runtime.RequiredError('clientId','Required parameter requestParameters.clientId was null or undefined when calling meClientsScopesControllerFindAll.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("ias", ["@admin.island.is/auth", "@admin.island.is/auth:admin"]);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/v2/me/tenants/{tenantId}/clients/{clientId}/scopes`.replace(`{${"tenantId"}}`, encodeURIComponent(String(requestParameters.tenantId))).replace(`{${"clientId"}}`, encodeURIComponent(String(requestParameters.clientId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AdminScopeDTOFromJSON));
    }

    /**
     * Gets all allowed scopes for the specified client and tenant.
     */
    async meClientsScopesControllerFindAll(requestParameters: MeClientsScopesControllerFindAllRequest): Promise<Array<AdminScopeDTO>> {
        const response = await this.meClientsScopesControllerFindAllRaw(requestParameters);
        return await response.value();
    }

    /**
     * Creates api scope for specific tenant.
     */
    async meScopesControllerCreateRaw(requestParameters: MeScopesControllerCreateRequest): Promise<runtime.ApiResponse<AdminScopeDTO>> {
        if (requestParameters.tenantId === null || requestParameters.tenantId === undefined) {
            throw new runtime.RequiredError('tenantId','Required parameter requestParameters.tenantId was null or undefined when calling meScopesControllerCreate.');
        }

        if (requestParameters.adminCreateScopeDto === null || requestParameters.adminCreateScopeDto === undefined) {
            throw new runtime.RequiredError('adminCreateScopeDto','Required parameter requestParameters.adminCreateScopeDto was null or undefined when calling meScopesControllerCreate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("ias", ["@admin.island.is/auth", "@admin.island.is/auth:admin"]);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/v2/me/tenants/{tenantId}/scopes`.replace(`{${"tenantId"}}`, encodeURIComponent(String(requestParameters.tenantId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AdminCreateScopeDtoToJSON(requestParameters.adminCreateScopeDto),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AdminScopeDTOFromJSON(jsonValue));
    }

    /**
     * Creates api scope for specific tenant.
     */
    async meScopesControllerCreate(requestParameters: MeScopesControllerCreateRequest): Promise<AdminScopeDTO> {
        const response = await this.meScopesControllerCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get all scopes by tenant id.
     */
    async meScopesControllerFindAllByTenantIdRaw(requestParameters: MeScopesControllerFindAllByTenantIdRequest): Promise<runtime.ApiResponse<Array<AdminScopeDTO>>> {
        if (requestParameters.tenantId === null || requestParameters.tenantId === undefined) {
            throw new runtime.RequiredError('tenantId','Required parameter requestParameters.tenantId was null or undefined when calling meScopesControllerFindAllByTenantId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("ias", ["@admin.island.is/auth", "@admin.island.is/auth:admin"]);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/v2/me/tenants/{tenantId}/scopes`.replace(`{${"tenantId"}}`, encodeURIComponent(String(requestParameters.tenantId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AdminScopeDTOFromJSON));
    }

    /**
     * Get all scopes by tenant id.
     */
    async meScopesControllerFindAllByTenantId(requestParameters: MeScopesControllerFindAllByTenantIdRequest): Promise<Array<AdminScopeDTO>> {
        const response = await this.meScopesControllerFindAllByTenantIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get scope by name and tenant id.
     */
    async meScopesControllerFindByTenantIdAndScopeNameRaw(requestParameters: MeScopesControllerFindByTenantIdAndScopeNameRequest): Promise<runtime.ApiResponse<AdminScopeDTO>> {
        if (requestParameters.tenantId === null || requestParameters.tenantId === undefined) {
            throw new runtime.RequiredError('tenantId','Required parameter requestParameters.tenantId was null or undefined when calling meScopesControllerFindByTenantIdAndScopeName.');
        }

        if (requestParameters.scopeName === null || requestParameters.scopeName === undefined) {
            throw new runtime.RequiredError('scopeName','Required parameter requestParameters.scopeName was null or undefined when calling meScopesControllerFindByTenantIdAndScopeName.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("ias", ["@admin.island.is/auth", "@admin.island.is/auth:admin"]);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/v2/me/tenants/{tenantId}/scopes/{scopeName}`.replace(`{${"tenantId"}}`, encodeURIComponent(String(requestParameters.tenantId))).replace(`{${"scopeName"}}`, encodeURIComponent(String(requestParameters.scopeName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AdminScopeDTOFromJSON(jsonValue));
    }

    /**
     * Get scope by name and tenant id.
     */
    async meScopesControllerFindByTenantIdAndScopeName(requestParameters: MeScopesControllerFindByTenantIdAndScopeNameRequest): Promise<AdminScopeDTO> {
        const response = await this.meScopesControllerFindByTenantIdAndScopeNameRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update a scope with partial set of properties.
     */
    async meScopesControllerUpdateRaw(requestParameters: MeScopesControllerUpdateRequest): Promise<runtime.ApiResponse<AdminScopeDTO>> {
        if (requestParameters.tenantId === null || requestParameters.tenantId === undefined) {
            throw new runtime.RequiredError('tenantId','Required parameter requestParameters.tenantId was null or undefined when calling meScopesControllerUpdate.');
        }

        if (requestParameters.scopeName === null || requestParameters.scopeName === undefined) {
            throw new runtime.RequiredError('scopeName','Required parameter requestParameters.scopeName was null or undefined when calling meScopesControllerUpdate.');
        }

        if (requestParameters.adminPatchScopeDto === null || requestParameters.adminPatchScopeDto === undefined) {
            throw new runtime.RequiredError('adminPatchScopeDto','Required parameter requestParameters.adminPatchScopeDto was null or undefined when calling meScopesControllerUpdate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("ias", ["@admin.island.is/auth", "@admin.island.is/auth:admin"]);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/v2/me/tenants/{tenantId}/scopes/{scopeName}`.replace(`{${"tenantId"}}`, encodeURIComponent(String(requestParameters.tenantId))).replace(`{${"scopeName"}}`, encodeURIComponent(String(requestParameters.scopeName))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: AdminPatchScopeDtoToJSON(requestParameters.adminPatchScopeDto),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AdminScopeDTOFromJSON(jsonValue));
    }

    /**
     * Update a scope with partial set of properties.
     */
    async meScopesControllerUpdate(requestParameters: MeScopesControllerUpdateRequest): Promise<AdminScopeDTO> {
        const response = await this.meScopesControllerUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get all tenants for the current user.
     */
    async meTenantsControllerFindAllRaw(): Promise<runtime.ApiResponse<Array<TenantDto>>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("ias", ["@admin.island.is/auth", "@admin.island.is/auth:admin"]);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/v2/me/tenants`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TenantDtoFromJSON));
    }

    /**
     * Get all tenants for the current user.
     */
    async meTenantsControllerFindAll(): Promise<Array<TenantDto>> {
        const response = await this.meTenantsControllerFindAllRaw();
        return await response.value();
    }

    /**
     * Get tenant by id for the current user.
     */
    async meTenantsControllerFindByIdRaw(requestParameters: MeTenantsControllerFindByIdRequest): Promise<runtime.ApiResponse<TenantDto>> {
        if (requestParameters.tenantId === null || requestParameters.tenantId === undefined) {
            throw new runtime.RequiredError('tenantId','Required parameter requestParameters.tenantId was null or undefined when calling meTenantsControllerFindById.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("ias", ["@admin.island.is/auth", "@admin.island.is/auth:admin"]);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/v2/me/tenants/{tenantId}`.replace(`{${"tenantId"}}`, encodeURIComponent(String(requestParameters.tenantId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TenantDtoFromJSON(jsonValue));
    }

    /**
     * Get tenant by id for the current user.
     */
    async meTenantsControllerFindById(requestParameters: MeTenantsControllerFindByIdRequest): Promise<TenantDto> {
        const response = await this.meTenantsControllerFindByIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Fetch all delegationProviders and their delegationTypes
     */
    async providersControllerGetDelegationProvidersRaw(): Promise<runtime.ApiResponse<PaginatedDelegationProviderDto>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("ias", ["@admin.island.is/auth", "@admin.island.is/auth:admin"]);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/v2/providers`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedDelegationProviderDtoFromJSON(jsonValue));
    }

    /**
     * Fetch all delegationProviders and their delegationTypes
     */
    async providersControllerGetDelegationProviders(): Promise<PaginatedDelegationProviderDto> {
        const response = await this.providersControllerGetDelegationProvidersRaw();
        return await response.value();
    }

}
