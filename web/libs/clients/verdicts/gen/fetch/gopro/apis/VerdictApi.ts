/* tslint:disable */
/* eslint-disable */
/**
 * GoPro External Integration REST Services - API version 1.0
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    AddVerdictDocumentRequest,
    AddVerdictDocumentRequestFromJSON,
    AddVerdictDocumentRequestToJSON,
    GetCaseCategoriesResponse,
    GetCaseCategoriesResponseFromJSON,
    GetCaseCategoriesResponseToJSON,
    GetCaseTypesResponse,
    GetCaseTypesResponseFromJSON,
    GetCaseTypesResponseToJSON,
    GetKeywordsResponse,
    GetKeywordsResponseFromJSON,
    GetKeywordsResponseToJSON,
    GetVerdictResponse,
    GetVerdictResponseFromJSON,
    GetVerdictResponseToJSON,
    GetVerdictsRequest,
    GetVerdictsRequestFromJSON,
    GetVerdictsRequestToJSON,
    GetVerdictsResponse,
    GetVerdictsResponseFromJSON,
    GetVerdictsResponseToJSON,
    PublishVerdictRequest,
    PublishVerdictRequestFromJSON,
    PublishVerdictRequestToJSON,
    ReferenceResponse,
    ReferenceResponseFromJSON,
    ReferenceResponseToJSON,
} from '../models';

export interface AddVerdictDocumentOperationRequest {
    requestData: AddVerdictDocumentRequest;
    token?: string;
}

export interface GetCaseCategoriesRequest {
    token?: string;
}

export interface GetCaseTypesRequest {
    token?: string;
}

export interface GetKeywordsRequest {
    token?: string;
}

export interface GetVerdictRequest {
    id: string;
    token?: string;
}

export interface GetVerdictsOperationRequest {
    requestData: GetVerdictsRequest;
    token?: string;
}

export interface PublishVerdictOperationRequest {
    requestData: PublishVerdictRequest;
    token?: string;
}

/**
 * 
 */
export class VerdictApi extends runtime.BaseAPI {

    /**
     * Upload a PDF representation of the verdict.  Unique id of the published verdict: verdictID  Base64 encoded content of the PDF document: content
     */
    async addVerdictDocumentRaw(requestParameters: AddVerdictDocumentOperationRequest): Promise<runtime.ApiResponse<ReferenceResponse>> {
        if (requestParameters.requestData === null || requestParameters.requestData === undefined) {
            throw new runtime.RequiredError('requestData','Required parameter requestParameters.requestData was null or undefined when calling addVerdictDocument.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/Verdict/addVerdictDocument`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AddVerdictDocumentRequestToJSON(requestParameters.requestData),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ReferenceResponseFromJSON(jsonValue));
    }

    /**
     * Upload a PDF representation of the verdict.  Unique id of the published verdict: verdictID  Base64 encoded content of the PDF document: content
     */
    async addVerdictDocument(requestParameters: AddVerdictDocumentOperationRequest): Promise<ReferenceResponse> {
        const response = await this.addVerdictDocumentRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get list of case categories in use
     */
    async getCaseCategoriesRaw(requestParameters: GetCaseCategoriesRequest): Promise<runtime.ApiResponse<GetCaseCategoriesResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/Verdict/getCaseCategories`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => GetCaseCategoriesResponseFromJSON(jsonValue));
    }

    /**
     * Get list of case categories in use
     */
    async getCaseCategories(requestParameters: GetCaseCategoriesRequest): Promise<GetCaseCategoriesResponse> {
        const response = await this.getCaseCategoriesRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get list of case templates in use
     */
    async getCaseTypesRaw(requestParameters: GetCaseTypesRequest): Promise<runtime.ApiResponse<GetCaseTypesResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/Verdict/getCaseTypes`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => GetCaseTypesResponseFromJSON(jsonValue));
    }

    /**
     * Get list of case templates in use
     */
    async getCaseTypes(requestParameters: GetCaseTypesRequest): Promise<GetCaseTypesResponse> {
        const response = await this.getCaseTypesRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get list of keywords
     */
    async getKeywordsRaw(requestParameters: GetKeywordsRequest): Promise<runtime.ApiResponse<GetKeywordsResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/Verdict/getKeywords`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => GetKeywordsResponseFromJSON(jsonValue));
    }

    /**
     * Get list of keywords
     */
    async getKeywords(requestParameters: GetKeywordsRequest): Promise<GetKeywordsResponse> {
        const response = await this.getKeywordsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get a detailed verdict data specified by unique ID
     */
    async getVerdictRaw(requestParameters: GetVerdictRequest): Promise<runtime.ApiResponse<GetVerdictResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getVerdict.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/Verdict/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => GetVerdictResponseFromJSON(jsonValue));
    }

    /**
     * Get a detailed verdict data specified by unique ID
     */
    async getVerdict(requestParameters: GetVerdictRequest): Promise<GetVerdictResponse> {
        const response = await this.getVerdictRaw(requestParameters);
        return await response.value();
    }

    /**
     * Search verdicts.  Using advanced key search and multiple criteria parameters.  Use \"orderBy\" expression parameter. Syntax: sort_field [ ASC | DESC ] [ , ...n ]  Supported fields for sort_field: { Court | Casetype | CaseNumber | Category | Title | VerdictDate | PublishDate }  Samples: \"Court ASC\", \"Court, VerdictDate DESC\"
     */
    async getVerdictsRaw(requestParameters: GetVerdictsOperationRequest): Promise<runtime.ApiResponse<GetVerdictsResponse>> {
        if (requestParameters.requestData === null || requestParameters.requestData === undefined) {
            throw new runtime.RequiredError('requestData','Required parameter requestParameters.requestData was null or undefined when calling getVerdicts.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/Verdict/getVerdicts`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GetVerdictsRequestToJSON(requestParameters.requestData),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => GetVerdictsResponseFromJSON(jsonValue));
    }

    /**
     * Search verdicts.  Using advanced key search and multiple criteria parameters.  Use \"orderBy\" expression parameter. Syntax: sort_field [ ASC | DESC ] [ , ...n ]  Supported fields for sort_field: { Court | Casetype | CaseNumber | Category | Title | VerdictDate | PublishDate }  Samples: \"Court ASC\", \"Court, VerdictDate DESC\"
     */
    async getVerdicts(requestParameters: GetVerdictsOperationRequest): Promise<GetVerdictsResponse> {
        const response = await this.getVerdictsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Register or update a verdict in public registry by court, external case id and number, title and announcement date.  If case by specified court and external id is already published then it is updated
     */
    async publishVerdictRaw(requestParameters: PublishVerdictOperationRequest): Promise<runtime.ApiResponse<ReferenceResponse>> {
        if (requestParameters.requestData === null || requestParameters.requestData === undefined) {
            throw new runtime.RequiredError('requestData','Required parameter requestParameters.requestData was null or undefined when calling publishVerdict.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/Verdict/publishVerdict`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PublishVerdictRequestToJSON(requestParameters.requestData),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ReferenceResponseFromJSON(jsonValue));
    }

    /**
     * Register or update a verdict in public registry by court, external case id and number, title and announcement date.  If case by specified court and external id is already published then it is updated
     */
    async publishVerdict(requestParameters: PublishVerdictOperationRequest): Promise<ReferenceResponse> {
        const response = await this.publishVerdictRaw(requestParameters);
        return await response.value();
    }

}
